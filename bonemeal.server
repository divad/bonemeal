#!/usr/bin/python

import urwid
import platform   # for get hostname and configure
import os         # for get network interfaces
import os.path    # for install section
import socket     # for get ip from hostname
import subprocess # for sysexec
import requests   # for auth/register
import syslog     # syslogging
import logging
import time

from netaddr import IPAddress, IPNetwork

SETUP_TITLE           = ' UoS RHEL Server Installer';
SETUP_VERSION         = '2016-01-08-01';
PUPPET_SSL_ROOT       = '/etc/puppetlabs/puppet/ssl/'
PUPPET_BINARY         = '/opt/puppetlabs/bin/puppet'
PUPPET_MASTER_FQDN    = 'judy.puppet.soton.ac.uk'
DIORITE_URL           = 'https://judy.puppet.soton.ac.uk:5000/getcert/user'
DIORITE_SSL_CA_FILE   = '/tmp/puppetca.pem'

## NETWORK CONFIGS
NETWORKS_LIST = [IPNetwork("152.78.128.0/22"),
	IPNetwork("152.78.136.0/22"),
	IPNetwork("192.168.168.0/22"),
	IPNetwork("152.78.140.0/23"),
	IPNetwork("152.78.142.0/23"),
	IPNetwork("152.78.155.0/24"),
	IPNetwork("10.18.36.0/22")
]

ROUTERS_MAP = {
	"152.78.128.0/22":  '152.78.128.17',
	"152.78.136.0/22":  '152.78.137.254',
	"192.168.168.0/22": '192.168.171.254',
	"152.78.140.0/23":  '152.78.141.254',
	"152.78.142.0/23":  '152.78.143.254',
	"152.78.155.0/24":  '152.78.155.254',
	"10.18.36.0/22":    '10.18.39.254',
}

## TODO rhel6 support
	
class Bonemeal:

	palette = [
		('edit', 'black', 'light gray'),
        ('header',       'white',      'dark red',   'bold'),
        ('label',       'white',      'dark blue',   'bold'),
		('bg','white','dark blue'),
		('error','yellow','dark blue')
		]

	start = True
	finish = False

################################################################################

	def main(self):
		# logging
		self.log    = logging.getLogger("bonemeal")
		fileHandler = logging.FileHandler('/root/install.log')
		fileHandler.setFormatter(logging.Formatter('%(asctime)s %(levelname)s: %(message)s [in %(pathname)s:%(lineno)d]'))
		self.log.addHandler(fileHandler)
		self.log.setLevel(logging.INFO)

		# make tab work like down arrow
		urwid.command_map['tab'] = 'cursor down'

		## log the startup
		self.log.info("bonemeal installer version " + SETUP_VERSION + " starting up")

		self.setup_header_footer()
		self.loop = urwid.MainLoop(self.view_default(), self.palette, unhandled_input=self.unhandled_input)
		self.loop.run()

	def fatal(self,message):
		self.log.critical("fatal error: " + message)
		self.view_fatal_error(message)

	def switch_view(self,view):
		self.loop.widget = view
		self.loop.draw_screen()

	def setup_header_footer(self):
		self.header_text = urwid.Text(SETUP_TITLE)
		self.header = urwid.AttrWrap(self.header_text, 'header')
		self.footer_text = urwid.Text("bonemeal installer " + SETUP_VERSION)
		self.footer = urwid.AttrWrap(self.footer_text, 'header')

	def unhandled_input(self,key):
		if self.start:
			self.view_sethostname()
			self.start = False
		elif self.finish:
			self.clean_finish()
		elif key == 'Q':
			raise urwid.ExitMainLoop()

	def sysexec(self,command,shell=False):
		self.log.info("executing command: " + str(command))

		try:
			proc = subprocess.Popen(command,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,shell=shell)
			(stdoutdata, stderrdata) = proc.communicate()
			return (proc.returncode,str(stdoutdata),str(stderrdata))
		except Exception as ex:
			self.log.error("command generated an exception: " + str(ex))
			return (1,"",str(ex))

	def handle_exit(self,button):
		raise urwid.ExitMainLoop()

################################################################################

	## functions to lookup data from the local system
	def get_system_hostname(self):
		name = platform.node()
		self.log.info("detected hostname as " + name)
		return name

	def get_network_interfaces(self):
		try:
			entries = os.listdir("/sys/class/net")
		except OSError as e:
			self.fatal("Could not obtain the list of local network interfaces: " + str(e))
			return None

		try:
			entries.remove('lo')
		except ValueError as ex:
			pass

		return entries

	def get_ip_from_hostname(self):
		try:
			ip = socket.gethostbyname(self.hostname)
			self.log.info("IP address found in DNS for hostname: " + ip)
			return ip
		except socket.gaierror as e:
			self.log.info("No IP address found in DNS for given hostname")
			return ""

################################################################################
## DEFAULT VIEW

	def view_default(self):

		div = urwid.Divider()
		bt = urwid.BigText('I am ready to build', font=urwid.font.HalfBlock5x4Font())
		btwp = urwid.Padding(bt, "center", 'clip')

		txt = urwid.Text(u"Press any key to get started",align='center')
		pile1 = urwid.Pile([btwp,div,txt])
		pile1 = urwid.Filler(pile1, 'middle', None, 7)

		frame = urwid.Frame(header=self.header, body=pile1, footer=self.footer)
		return urwid.AttrMap(frame, 'bg')

################################################################################
## SET HOSTNAME

	def view_sethostname(self):
		div = urwid.Divider()

		htxt = urwid.Text(u"Welcome to the installation wizard. Please enter the hostname of the server. Use the arrow keys to move between fields.",align='left')

		self.hostname_edit = urwid.Edit( caption=('label'," Hostname:  "),edit_text=self.get_system_hostname())
		ed = urwid.AttrMap(self.hostname_edit, 'edit')

		button = urwid.Button("Continue")
		urwid.connect_signal(button, 'click', self.handle_hostname)
		button = urwid.Padding(button,"center", width=12)

		self.hostname_error = urwid.Text(u"",align='left')
		err = urwid.AttrMap(self.hostname_error, 'error')

		pile = urwid.Pile([div,htxt,div,ed,div,button,div,err])
		pile = urwid.Padding(pile, "left", left=1,right=1)
		fill = urwid.Filler(pile, 'top')
		frame = urwid.Frame(header=self.header, body=fill, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

	def handle_hostname(self,button):
		self.hostname = self.hostname_edit.get_edit_text()

		if self.hostname.endswith(".soton.ac.uk"):
			self.log.info("stripping .soton.ac.uk from given hostname")
			self.hostname = self.hostname = self.hostname[:-len(".soton.ac.uk")]

		if "." in self.hostname:
			self.hostname_error.set_text("That hostname is invalid. Please try again.")
			return

		self.log.info("chosen hostname: " + self.hostname)

		# Strip off the domain
		self.fqdn = self.hostname + ".soton.ac.uk"

		self.log.info("chosen fqdn: " + self.fqdn)

		self.footer_text.set_text(self.fqdn)
		self.view_choosenet()

################################################################################
## CHOOSE NETWORK INTERFACE

	def view_choosenet(self):
		interfaces = self.get_network_interfaces()

		if interfaces == None:
			return

		if len(interfaces) == 1:
			## set interface to the only one in the list
			self.netif = interfaces[0]
			self.log.info("only one network interface: " + self.netif)
			self.footer_text.set_text(self.fqdn + " / " + self.netif)
			self.view_setipaddr()
			return

		btns = []
		for name in interfaces:
			button = urwid.Button(name)
			urwid.connect_signal(button, 'click', self.handle_interfaces, name)
			btns.append(button)

		listbox = urwid.ListBox(urwid.SimpleFocusListWalker(btns))
		listbox = urwid.BoxAdapter(listbox,len(interfaces))
		# so clayton made me write the max thing. what it does is get the max width/length of the strings in the network list
		listbox = urwid.Padding(listbox, "left", width=max([len(name) for name in interfaces]) + 4)

		div = urwid.Divider()

		htxt = urwid.Text(u"Please choose a network interface to configure.",align='left')

		pile = urwid.Pile([div,htxt,div,listbox])

		pile = urwid.Padding(pile, "left", left=1,right=1)
		fill = urwid.Filler(pile, 'top')

		frame = urwid.Frame(header=self.header, body=fill, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

	def handle_interfaces(self,button,chosen_interface):
		self.netif = chosen_interface
		self.log.info("chosen network interface: " + self.netif)
		self.footer_text.set_text(self.fqdn + " / " + self.netif)
		self.view_setipaddr()

################################################################################
## SET IP ADDRESS

	def view_setipaddr(self):
		div = urwid.Divider()

		htxt = urwid.Text(u"Please your chosen IP address for interface " + self.netif,align='left')

		self.ipaddr_edit = urwid.Edit( caption=('label'," IP Address:  "),edit_text=self.get_ip_from_hostname())
		ed = urwid.AttrMap(self.ipaddr_edit, 'edit')

		mtxt = urwid.Text(u"If present the IP address above was calculated from the hostname you gave earlier. The netmask and router/gateway will be determined automatically based on the network the address is within. DHCP is not recommended on production servers but can be used on development systems for testing.",align='left')

		button1 = urwid.Button("Continue")
		urwid.connect_signal(button1, 'click', self.handle_ipaddr)

		button2 = urwid.Button("Use DHCP")
		urwid.connect_signal(button2, 'click', self.handle_dhcp)
		
		col = urwid.Columns([button1,button2],4)

		col = urwid.Padding(col,"center", width=28)

		self.ipaddr_error = urwid.Text(u"",align='left')
		err = urwid.AttrMap(self.ipaddr_error, 'error')

		pile = urwid.Pile([div,htxt,div,ed,div,col,div,err,div,mtxt])
		pile = urwid.Padding(pile, "left", left=1,right=1)
		fill = urwid.Filler(pile, 'top')
		frame = urwid.Frame(header=self.header, body=fill, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

	def handle_ipaddr(self,button):
		self.ipaddr = self.ipaddr_edit.get_edit_text()
		self.dhcp = False

		## validate the ip address
		try:
			address = IPAddress(self.ipaddr)
		except Exception as ex:
			self.ipaddr_error.set_text("That IP address is invalid. Please try again.")
			return

		## Now try to recognise the network it is within
		found = False
		for ipnet in NETWORKS_LIST:
			if address in ipnet:
				found = True
				self.netmask = ipnet.netmask
				self.router = ROUTERS_MAP[str(ipnet)]
				break

		if not found:
			self.ipaddr_error.set_text("That network is not valid for servers. You can choose DHCP if you wish instead.")
			return	

		self.log.info("static networking chosen")
		self.log.info("chosen IP address: " + str(self.ipaddr))
		self.log.info("router: " + str(self.router))
		self.log.info("netmask: " + str(self.netmask))

		self.footer_text.set_text(self.fqdn + " / " + self.netif + " / " + self.ipaddr)
		self.view_auth()	

	def handle_dhcp(self,button):
		self.log.info("dhcp networking chosen")
		self.dhcp = True
		self.footer_text.set_text(self.fqdn + " / " + self.netif + " / dhcp")
		self.view_auth()	

################################################################################
## AUTHENTICATE / REGISTER
		
	def view_auth(self):

		div = urwid.Divider()

		mtxt = urwid.Text(u"Please enter your University username and password in order to register this system.",align='left')

		self.username = urwid.Edit(caption=('label'," Username:  "),allow_tab=False)
		edituser = urwid.AttrMap(self.username, 'edit')
		self.password = urwid.Edit(caption=('label'," Password:  "),mask="*")
		editpass = urwid.AttrMap(self.password, 'edit')

		button1 = urwid.Button("Continue")
		urwid.connect_signal(button1, 'click', self.handle_auth)
		button1 = urwid.Padding(button1,"center", width=12)

		self.auth_error = urwid.Text(u"",align='left')
		err = urwid.AttrMap(self.auth_error, 'error')

		pile = urwid.Pile([div,mtxt,div,edituser,div,editpass,div,button1,div,err])
		pile = urwid.Padding(pile, "left", left=1,right=1)
		fill = urwid.Filler(pile, 'top')

		frame = urwid.Frame(header=self.header, body=fill, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

	def handle_auth(self,button):
		self.auth_error.set_text("Contacting server, please wait...")

		## python requests call with SSL...
		try:
			payload = {'ident': 'el7s', 'hostname': self.fqdn, 'username': self.username.get_edit_text(), 'password': self.password.get_edit_text()}
			r = requests.post(DIORITE_URL, data=payload, verify = DIORITE_SSL_CA_FILE)
		except Exception as ex:
			self.log.error("error contacting registration server: " + str(ex))
			self.auth_error.set_text("Error contacting registration server: " + str(ex))
			return				

		if r.status_code == 200:
			try:
				self.json = r.json()
				self.puppet_private_key = self.json['private_key']
				self.puppet_public_key  = self.json['public_key']
				self.puppet_cert        = self.json['cert']
				self.rhn_activation_key = self.json['rhn_activation_key']
			except Exception as ex:
				self.log.error("failed to parse response from registration server: " + str(ex))
				self.auth_error.set_text("Failed to parse return response: " + str(ex))
				return

			self.view_go()
			return	
		elif r.status_code == 403:
			self.auth_error.set_text("Authentication failed: Incorrect username/password")
			return
		else:
			self.log.error("unexpected return code from registration server: " + str(r.status_code))
			self.auth_error.set_text("Registration failed: Error code " + str(r.status_code))
			return

################################################################################
## DO INSTALL "GO"

	def view_go(self):
		div = urwid.Divider()

		self.msgs = urwid.SimpleFocusListWalker([urwid.Text(" ",align='left'),urwid.Text(" Starting post-install",align='left')])
		self.msgs_box = urwid.ListBox(self.msgs)

		frame = urwid.Frame(header=self.header, body=self.msgs_box, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

		## now do the install
		self.configure()

	def add_msg(self,message):
		self.log.info(message)
		self.msgs.append(urwid.Text(" " + message.rstrip(),align='left'))
		self.msgs_box.set_focus(len(self.msgs) -1)
		self.loop.draw_screen()

	def configure(self):

		self.warnings = 0

		## work out OS version
		(distname, distversion, distid) = platform.linux_distribution()

		if distid == 'Maipo':
			self.release = 7
			self.add_msg("Detected operating system as RHEL7")
		elif distid == 'Santiago':
			self.release = 6
			self.add_msg("Detected operating system as RHEL6")
		else:
			self.fatal("This operating system was not recognised. This installer supports RHEL6 or RHEL7.")
			return

		## set hostname
		if self.release == 7:
			(code, stdout, stderr) = self.sysexec(["/bin/hostnamectl","set-hostname",self.hostname])

			if code != 0:
				self.fatal("Setting hostname failed: \n" + stdout + "\n" + stderr)
				return
			else:
				self.add_msg("Short hostname set to '" + self.hostname + "'")
		elif self.release == 6:
			## TODO test new installer on RHEL6
			## add support for RHEL6
			self.fatal("bonemeal does not yet support RHEL6. ")
			return

		## set fqdn if not using dhcp
		if self.dhcp == False:
			try:
				with open("/etc/hosts", "a") as hosts_file:
					hosts_file.write(self.ipaddr + "\t" + self.fqdn + "\t" + self.hostname)
			except Exception as e:
				self.add_msg("WARNING: could not set fqdn in /etc/hosts:")
				self.add_msg(str(e))
				self.warnings = self.warnings + 1

		## todo dns domain name for dhcp (/etc/dnsdomainname maybe?)

		## do networking config file

		## restart the network interface using ifdown/ifup
		self.add_msg("Stopping network manager")
		(code, stdout, stderr) = self.sysexec(["/bin/systemctl","stop","NetworkManager"])

		if code != 0:
			self.fatal("Could not stop the NetworkManager service: \n" + stdout + "\n" + stderr)
			return

		## check the config file exists (it should...)
		self.add_msg("Attempting to read existing network configuration")
		network_config_file = "/etc/sysconfig/network-scripts/ifcfg-" + self.netif
		if os.path.isfile(network_config_file): 
			try:
				with open(network_config_file, "r") as netcfg_file:
					netcfg = netcfg_file.readlines()
			except Exception as e:
				self.add_msg("WARNING: could not read network config file " + network_config_file)
				self.add_msg("WARNING: Because I can't read the existing config file the network interface is unlikely to work")
				self.add_msg(str(e))
				netcfg = []
				self.warnings = self.warnings + 1
		else:
			self.add_msg("WARNING: No existing network configuration file found for interface " + self.netif)
			self.add_msg("WARNING: Because there is no existing config file the network interface is unlikely to work")
			netcfg = []
			self.warnings = self.warnings + 1

		self.add_msg("Generating new network configuration")

		## remove parts of the existing file we dont want
		netcfg = [x for x in netcfg if self.netcfg_remove(x)]

		## now add in what we want
		netcfg.append("PEERDNS=no\n")

		if self.dhcp:
			netcfg.append("BOOTPROTO=dhcp\n")
		else:
			netcfg.append("BOOTPROTO=static\n")
			netcfg.append("IPADDR=" + self.ipaddr + "\n")
			netcfg.append("NETMASK=" + str(self.netmask) + "\n")
			netcfg.append("GATEWAY=" + self.router + "\n")

		if self.release == 6:
			netcfg.append("NM_CONTROLLED=no\n")

		## now write out the file
		self.add_msg("Saving new network configuration")
		try:
			with open(network_config_file, "w") as fp:
				for line in netcfg:
					fp.write(line)
			self.add_msg("Saved new network configuration")
		except Exception as e:
			self.fatal("Could not write to network config file " + network_config_file + ":\n" + str(ex))
			return

		## restart the network interface using ifdown/ifup
		self.add_msg("Stopping network interface " + self.netif)
		(code, stdout, stderr) = self.sysexec(["/sbin/ifdown",self.netif])

		if code != 0:
			self.fatal("Could not stop network interface " + self.netif + ": \n" + stdout + "\n" + stderr)
			return

		self.add_msg("Starting network interface " + self.netif)
		(code, stdout, stderr) = self.sysexec(["/sbin/ifup",self.netif])

		if code != 0:
			self.fatal("Could not start network interface " + self.netif + ": \n" + stdout + "\n" + stderr)
			return
		else:
			self.add_msg("Started network interface " + self.netif)

		## because we set PEERDNS=no in the network settings the system has no idea, even with dhcp, what dns servers to use.
		## puppet will set them later, but we still need dns servers before that, so we'll write out a sample
		## resolv.conf to bootstrap us to puppet.
		## we set PEERDNS=no because puppet manages resolv.conf normally and we dont want the network and puppet fighting over the resolv.conf file.
		self.log.info("Saving temporary resolv.conf file")
		try:
			with open("/etc/resolv.conf", "w") as fp:
				fp.write("""search soton.ac.uk
nameserver 152.78.110.110
nameserver 152.78.111.81
nameserver 152.78.111.113
""")
		except Exception as ex:
			self.fatal("Could not write to /etc/resolv.conf:\n" + str(ex))
			return

		## REGISTER WITH RHN
		self.add_msg("Preparing to register with RH Satellite")
		(code, stdout, stderr) = self.sysexec(["wget","-q","-O","/tmp/rhn-org-trusted-ssl-cert-1.0-1.noarch.rpm","https://rhn.soton.ac.uk/pub/rhn-org-trusted-ssl-cert-1.0-1.noarch.rpm","--no-check-certificate"])

		if code != 0:
			self.fatal("Could not download satellite SSL certificate RPM: \n" + stdout + "\n" + stderr)
			return

		## See if the rpm is already installed
		(code, stdout, stderr) = self.sysexec(["/bin/rpm","-qi","rhn-org-trusted-ssl-cert"])

		if code == 0:
			self.add_msg("NOTICE: rhn-org-trusted-ssl-cert was found to be already installed")
		else:
			(code, stdout, stderr) = self.sysexec(["/bin/rpm","-ivh","/tmp/rhn-org-trusted-ssl-cert-1.0-1.noarch.rpm"])

			if code != 0:
				self.fatal("Could not install satellite SSL certificate RPM: \n" + stdout + "\n" + stderr)
				return

		(code, stdout, stderr) = self.sysexec(["/bin/wget","-q","-O","/etc/sysconfig/rhn/up2date","https://rhn.soton.ac.uk/pub/up2date","--no-check-certificate"])

		if code != 0:
			self.fatal("Could not download up2date config file: \n" + stdout + "\n" + stderr)
			return

		self.add_msg("Registering with RH Satellite")

		(code, stdout, stderr) = self.sysexec('/sbin/rhnreg_ks --force --activationkey="' + self.rhn_activation_key + '"',shell=True) 

		if code != 0:
			self.fatal("Could not register with Red Hat Satellite: \n" + stdout + "\n" + stderr)
			return
		else:
			self.add_msg("Satellite registration successful")

		## iSolutions GPG Key

		(code, stdout, stderr) = self.sysexec(["/bin/wget","-q","-O","/etc/pki/rpm-gpg/ISOLUTIONS-PUBLIC-KEY","https://rhn.soton.ac.uk/pub/ISOLUTIONS-PUBLIC-KEY","--no-check-certificate"])

		if code != 0:
			self.fatal("Could not download the iSolutions RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		(code, stdout, stderr) = self.sysexec(["/bin/rpm","--import","/etc/pki/rpm-gpg/ISOLUTIONS-PUBLIC-KEY"])

		if code != 0:
			self.fatal("Could not import the iSolutions RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		## EPEL 7 GPG Key
		(code, stdout, stderr) = self.sysexec(["/bin/wget","-q","-O","/etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL","https://rhn.soton.ac.uk/pub/RPM-GPG-KEY-EPEL-7","--no-check-certificate"])

		if code != 0:
			self.fatal("Could not download the EPEL RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		(code, stdout, stderr) = self.sysexec(["/bin/rpm","--import","/etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL"])

		if code != 0:
			self.fatal("Could not import the EPEL RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		## PuppetLabs Yum Repository GPG Key
		(code, stdout, stderr) = self.sysexec(["/bin/wget","-q","-O","/etc/pki/rpm-gpg/RPM-GPG-KEY-PUPPET-COLLECTIONS","https://rhn.soton.ac.uk/pub/RPM-GPG-KEY-PUPPET-COLLECTIONS","--no-check-certificate"])

		if code != 0:
			self.fatal("Could not download the Puppet RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		(code, stdout, stderr) = self.sysexec(["/bin/rpm","--import","/etc/pki/rpm-gpg/RPM-GPG-KEY-PUPPET-COLLECTIONS"])

		if code != 0:
			self.fatal("Could not import the Puppet RPM GPG key: \n" + stdout + "\n" + stderr)
			return

		## APPLY SOFTWARE UPDATES
		self.add_msg("Installing software updates")
		(code, stdout, stderr) = self.sysexec("/usr/bin/yum -y update",shell=True)

		if code != 0:
			self.add_msg("WARNING: non-zero exit occured during yum update:")
			self.add_msg(stdout)
			self.add_msg(stderr)
			self.warnings = self.warnings + 1

		# a dependency on our use of puppet is lsb based facter variables
		# so we install it first.
		self.add_msg("Installing redhat-lsb-core package")
		(code, stdout, stderr) = self.sysexec("/usr/bin/yum -y install redhat-lsb-core",shell=True)

		if code != 0:
			self.fatal("Could not install redhat-lsb-core: \n" + stdout + "\n" + stderr)
			return

		## INSTALL PUPPET
		self.add_msg("Installing Puppet")
		(code, stdout, stderr) = self.sysexec("/usr/bin/yum -y install puppet-agent",shell=True)

		if code != 0:
			self.fatal("Could not install Puppet: \n" + stdout + "\n" + stderr)
			return

		## SET CONFIG - server
		self.add_msg("Setting Puppet master to " + PUPPET_MASTER_FQDN)
		(code, stdout, stderr) = self.sysexec(PUPPET_BINARY + " config set server " + PUPPET_MASTER_FQDN,shell=True)

		if code != 0:
			self.fatal("Could not set puppet master: \n" + stdout + "\n" + stderr)
			return

		## SET CONFIG - certname
		self.add_msg("Setting Puppet certname to " + self.fqdn)
		(code, stdout, stderr) = self.sysexec(PUPPET_BINARY + " config set certname	 " + self.fqdn,shell=True)

		if code != 0:
			self.fatal("Could not set puppet certname: \n" + stdout + "\n" + stderr)
			return

		## Run Puppet fingerprint. This sets up the SSL dir and generates some files but thats it.
		self.add_msg("Setting up Puppet SSL directory")
		(code, stdout, stderr) = self.sysexec(PUPPET_BINARY + " agent --Qfingerprint",shell=True)

		## Deploy certificates and set certname option in puppet.conf
		self.add_msg("Saving puppet certificates")
		try:
			with open(PUPPET_SSL_ROOT + "certs/" + self.fqdn + ".pem", "w") as fp:
				fp.write(self.puppet_cert)

			with open(PUPPET_SSL_ROOT + "public_keys/" + self.fqdn + ".pem", "w") as fp:
				fp.write(self.puppet_public_key)

			with open(PUPPET_SSL_ROOT + "private_keys/" + self.fqdn + ".pem", "w") as fp:
				fp.write(self.puppet_private_key)
		except Exception as ex:
			self.fatal("Could not save puppet certificate files:\n" + str(ex))
			return

		self.add_msg("Applying puppet policy to the system")
		## we run twice just to be sure. we only care about the exit code of the second
		self.sysexec(PUPPET_BINARY + " agent --test",shell=True)
		(code, stdout, stderr) = self.sysexec(PUPPET_BINARY + " agent --test",shell=True)

		if code != 0 and code != 2:
			self.fatal("Puppet reported an error when applying policy to this system: \n" + stdout + "\n" + stderr)
			return

		## Set Puppet to run all the time
		self.add_msg("Setting Puppet to launch on startup")
		(code, stdout, stderr) = self.sysexec("systemctl enable puppet",shell=True)

		if code != 0:
			self.add_msg("WARNING: Failed to configure Puppet to launch on startupsystem")
			self.add_msg(stdout)
			self.add_msg(stderr)
			self.warnings = self.warnings + 1

		self.view_finish()

	def netcfg_remove(self,line):
		removals = ['BOOTPROTO','DHCPCLASS','NM_CONTROLLED','IPADDR','NETMASK','GATEWAY','PEERDNS']

		for bad in removals:
			if line.startswith(bad):
				return False

		return True

################################################################################
## FINISH SCREEN

	def view_finish(self):

		div = urwid.Divider()
		bt = urwid.BigText('all done!', font=urwid.font.HalfBlock5x4Font())
		btwp = urwid.Padding(bt, "center", 'clip')

		txt = urwid.Text(u"Press any key to restart",align='center')

		if self.warnings == 0:
			pile1 = urwid.Pile([btwp,div,txt])
		elif self.warnings == 1:
			warn = urwid.Text("One warning was detected during installation. \nPlease review /root/install.log on reboot to check these warnings.",align='center')
			pile1 = urwid.Pile([btwp,div,txt,div,warn])
		else:
			warn = urwid.Text(str(self.warnings) + u" warnings were encountered during installation.\n Please review /root/install.log on reboot to check these warnings.",align='center')
			pile1 = urwid.Pile([btwp,div,txt,div,warn])

		pile1 = urwid.Filler(pile1, 'middle', None, 7)

		frame = urwid.Frame(header=self.header, body=pile1, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))
		self.finish = True

	def clean_finish(self):
		## disable the installer on next reboot
		self.sysexec("/bin/rm -f /etc/systemd/system/multi-user.target.wants/bonemeal.service",shell=True)

		## reboot
		self.sysexec("/sbin/reboot")

		## exit
		raise urwid.ExitMainLoop()

################################################################################
## FATAL ERROR SCREEN

	def view_fatal_error(self,message):
		div = urwid.Divider()

		bt = urwid.BigText('uh oh...', font=urwid.font.HalfBlock5x4Font())
		btwp = urwid.Padding(bt, "center", 'clip')
		htxt = urwid.Text(u"A fatal error occured:",align='left')
		mtxt = urwid.Text(message,align='left')

		button = urwid.Button("Exit installer")
		urwid.connect_signal(button, 'click', self.handle_exit)
		button = urwid.Padding(button,"center", width=18)

		pile = urwid.Pile([div,btwp,div,htxt,div,mtxt,div,button])
		pile = urwid.Padding(pile, "left", left=1,right=1)
		fill = urwid.Filler(pile, 'top')
		frame = urwid.Frame(header=self.header, body=fill, footer=self.footer)
		self.switch_view(urwid.AttrMap(frame, 'bg'))

################################################################################

if '__main__'==__name__:
	print "Please wait whilst loading the installer..."
	time.sleep(5)
	subprocess.call(["reset"])
	Bonemeal().main()
	subprocess.call(["reset"])
